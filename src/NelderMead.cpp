#include "NelderMead.hpp"

#include <cstring>   // memcpy
#include <iostream>  // cout, endl, bad_alloc

#ifndef DBL_MAX
#include <limits>  // numeric_limits
#define DBL_MAX std::numeric_limits<double>::max()
#endif

NelderMead::NelderMead(int _dim, double _error) : dim(_dim) {
  if (_dim < 1) {
    throw std::invalid_argument("Dimensional Value Invalid! Set _dim > 0.");
  }
  if (_error < 0) {
    throw std::invalid_argument("Invalid error! Set _error >= 0.");
  }
  n_points = (_dim > 2) ? (_dim + 1) : 3;

  try {
    points = new double *[n_points];
    costs = new double[n_points];
    centroid = new double[dim];
    best_point = new double[dim];
    point_reflection = new double[dim];   // point generated by reflection
    point_expansion = new double[dim];    // point generated by expansion
    point_contraction = new double[dim];  // point generated by contraction
    for (i = 0; i < n_points; i++) {
      points[i] = new double[dim];
    }
  } catch (const std::bad_alloc &e) {
    std::cout << "Memory Allocation"
              << " is failed: " << e.what() << std::endl;
  }

  h = n_points - 1;  // index of the worst solution
  s = n_points - 2;  // index of the second worst solution
  l = 0;             // index of the best solution

  cost_reflection = 0.0;   // Cost of reflected point
  cost_expansion = 0.0;    // Cost of expanded point
  cost_contraction = 0.0;  // Cost of contracted point

  alpha = A_LFA;   // Used in reflection
  gammma = G_AMA;  // Used in expansion
  rho = R_HO;      // Used in contraction
  sigma = S_GMA;   // Used in reduction

  result = 0.0;
  i = j = 0;
  i_points = 0;
  step = 0;

  error = _error;

  for (int i = 0; i < n_points; i++) {
    costs[i] = DBL_MAX;
  }

  // Generate inital points
  srand48_r(time(NULL), &buffer);  // random seed
  for (i = 0; i < n_points; i++) {
    for (j = 0; j < dim; j++) {
      drand48_r(&buffer, &result);          // random number in 'result'
      points[i][j] = (result * 2.0 - 1.0);  // numbers between -1 and 1.
    }
  }
}

double *NelderMead::run(double _cost) {
  do {
    switch (step) {
      case 0:  // Initialize Points
        if (i_points > 0) {
          costs[i_points - 1] = _cost;
        }
        if (i_points < n_points) {
          i_points++;
          return points[i_points - 1];
        }

      case 1:  // Initialize Variables
        sort_points();
        calculate_centroid();

      case 2:  // Reflection - Use alpha
        for (j = 0; j < dim; j++) {
          point_reflection[j] =
              fmod(centroid[j] + alpha * (centroid[j] - points[h][j]), 1);
        }
        step = 3;
        return point_reflection;

      case 3:
        cost_reflection = _cost;
        if (costs[l] <= cost_reflection && cost_reflection < costs[s]) {
          swap(point_reflection, points[h]);
          costs[h] = cost_reflection;
          break;
        } else if (cost_reflection < costs[l]) {
          // Calculate Expansion - Use gammma
          for (j = 0; j < dim; j++) {
            point_expansion[j] = fmod(
                centroid[j] + gammma * (point_reflection[j] - centroid[j]), 1);
          }
          step = 4;
          return point_expansion;
        } else if (costs[s] <= cost_reflection && cost_reflection < costs[h]) {
          // Calculate Outside Contraction - Use rho
          for (j = 0; j < dim; j++) {
            point_contraction[j] = fmod(
                centroid[j] + rho * (point_reflection[j] - centroid[j]), 1);
          }
          step = 5;
          return point_contraction;
        } else if (cost_reflection >= costs[h]) {
          // Calculate Inside Contraction - Use rho
          for (j = 0; j < dim; j++) {
            point_contraction[j] =
                fmod(centroid[j] - rho * (centroid[j]) - points[h][j], 1);
          }
          step = 6;
          return point_contraction;
        }

      case 4:
        cost_expansion = _cost;
        if (cost_expansion < cost_reflection) {
          swap(point_expansion, points[h]);
          costs[h] = cost_expansion;
        } else {
          swap(point_reflection, points[h]);
          costs[h] = cost_reflection;
        }
        break;

      case 5:
        cost_contraction = _cost;
        if (cost_contraction <= cost_reflection) {
          swap(point_contraction, points[h]);
          costs[h] = cost_contraction;
        } else {
          step = 7;
        }
        break;

      case 6:
        cost_contraction = _cost;
        if (cost_contraction < costs[h]) {
          swap(point_contraction, points[h]);
          costs[h] = cost_contraction;
          break;
        } else {
          step = 7;
          break;
        }
    }

    sort_points();
    if (step == 7) {
      // Replace all points, except the best_point
      for (int i = 0; i < n_points; i++) {
        if (i != l) {
          for (j = 0; j < dim; j++) {
            points[i][j] =
                fmod(points[l][j] + sigma * (points[i][j] - points[l][j]), 1);
          }
        }
      }
      step = 0;
      i_points = 1;
    }

    calculate_centroid();
    step = 2;

  } while (volume() > error);

  step = END;
  memcpy(best_point, points[l], dim * sizeof(double));

  return best_point;
}

void NelderMead::sort_points() {
  // Put in order solutions, ie, points[0][x] is the best, ...,
  // points[n+1][x] is the worst Bubble sort
  for (i = 0; i < n_points - 1; i++) {
    for (j = i + 1; j < n_points; j++) {
      if (costs[i] > costs[j]) {
        swap(points[i], points[j]);
        swap(costs[i], costs[j]);
      }
    }
  }
}

void NelderMead::calculate_centroid() {
  // Calculate centroid
  for (j = 0; j < dim; j++) {
    result = 0.0;
    centroid[j] = 0.0;  // Centroid = {0}
    for (i = 0; i < n_points; i++) {
      // The worst solution is not necessary
      if (i != h) {
        centroid[j] += points[i][j];
        result += 1.0;
      }
    }
    centroid[j] /= (result);
  }
}

void NelderMead::reset(int level) {
  cost_reflection = 0.0;   // Cost of reflected point
  cost_expansion = 0.0;    // Cost of expanded point
  cost_contraction = 0.0;  // Cost of contracted point

  result = 0.0;
  i_points = 0;
  step = 0;

  sort_points();
  switch (level) {
    case 0:  // Reset with random points removing the best point
      for (j = 0; j < dim; j++) {
        drand48_r(&buffer, &result);          // random number in 'result'
        points[l][j] = (result * 2.0 - 1.0);  // numbers between -1 and 1.
      }
    case 1:  // Reset with random points keeping the best point
      for (i = 0; i < n_points; i++) {
        if (i != l) {
          for (j = 0; j < dim; j++) {
            drand48_r(&buffer, &result);          // random number in 'result'
            points[i][j] = (result * 2.0 - 1.0);  // numbers between -1 and 1.
          }
        }
      }
      break;

    default:
      throw std::runtime_error(
          "There is not the Nelder-Mead reset option level " +
          std::to_string(level));
      break;
  }
}

double NelderMead::volume() {
  double value = 0.0;
  double total = 0.0;

  for (i = 0; i < n_points; i++) {
    value = 0.0;
    for (j = 0; j < dim; j++) {
      value += pow(points[i][j] - centroid[j], 2.0);
    }
    value = sqrt(value);      // With this calculation, 'value' is the norm.
    value = pow(value, 2.0);  // value is equal to normÂ²
    total += value;
  }
  return sqrt(total / n_points);
}

void NelderMead::swap(double *&p1, double *&p2) {
  double *temp = p1;
  p1 = p2;
  p2 = temp;
}

void NelderMead::swap(double &p1, double &p2) {
  double temp = p1;
  p1 = p2;
  p2 = temp;
}

NelderMead::~NelderMead() {
  for (int i = 0; i < n_points; i++) {
    delete[] points[i];
  }
  delete[] points;
  delete[] costs;
  delete[] centroid;
  delete[] best_point;
  delete[] point_reflection;
  delete[] point_expansion;
  delete[] point_contraction;
}