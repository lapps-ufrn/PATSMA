#ifndef _NELDER_MEAD_
#define _NELDER_MEAD_

#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
//#include "objective_functions.c"

#define MAX_VOLUME 1.0e-6

#ifndef A_LFA
#define A_LFA 1
#endif
#ifndef G_AMA
#define G_AMA 2
#endif
#ifndef R_HO
#define R_HO 0.5
#endif
#ifndef S_GMA
#define S_GMA 0.5
#endif

#define swap_worst(y)                  \
	nm->point_temp = nm->point[nm->h]; \
	nm->point[nm->h] = y;              \
	y = nm->point_temp;

typedef struct
{
	double alpha;		//Used in reflection
	double gammma;		//Used in expansion
	double rho;			//Used in contraction
	double sigma;		//Used in reduction

	int step;
	int h; 				//Index of the worst solution
	int s;				//Index of the second worst solution
	int l;				//Index of the best solution

	int numPoints;
	int dim;

	int i, j, k;					//Temporary int variables

	double  cost_reflection;		//Cost of reflected nm->point
	double  cost_expansion;			//Cost of expanded nm->point
	double  cost_contraction;		//Cost of contracted nm->point

	double* point_reflection;		//Point generated by reflection
	double *point_expansion;		//Point generated by expansion
	double *point_contraction;		//Point generated by contraction

	double** point; 				//Vector where each line will a solution 'dim'-dimentional
	double* initial_point; 			//Initial Points
	double* best_point;
	double* cost;
	double* centroid;


	double result;					//Temporary double variables
	double *point_temp;
	struct drand48_data buffer;		//To use in random seed

	double volume_;
	double error;
	int counter;					//Iteration number Número da interação
	int reset;						//Número de resets napó obter vomule mínimo
	

} NelderMead;

void set_points(NelderMead *nm);
void initial_variables(NelderMead *nm, int _dim, double _error, double _point[]);
void finalizeNM(NelderMead *nm);
void order(NelderMead *nm);
void calculate_centroid(NelderMead *nm);
void reset(NelderMead *nm);
void volume(NelderMead *nm);
double* NM(NelderMead *nm, double _cost);

#endif
