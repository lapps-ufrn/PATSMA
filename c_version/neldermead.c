#include "neldermead.h"

// double r(double value)
// {
// 	int i = value;
// 	if (value > 1.0)
// 		return (-1 + (value - i));
// 	else if (value < -1.0)
// 		return (1 + (value - i));
// 	return value;
// }
/**
 * Setar pontos iniciais ou novos pontos
 * nm : in - Valores Globais do NM
 */
void set_points(NelderMead *nm) {
  // Caso 1: Inicializa com pontos predefinidos
  if (nm->initial_point) {
    for (nm->i = 0; nm->i < nm->numPoints; nm->i++) {
      for (nm->j = 0; nm->j < nm->dim; nm->j++) {
        nm->point[nm->i] = (double *)malloc(sizeof(double) * nm->dim);
        nm->point[nm->i][nm->j] = nm->initial_point[nm->i * nm->dim + nm->j];
      }
    }
  }
  // Caso 2: Inicializa com pontos aleatórios  mantendo o melhor ponto
  else if (nm->step == -1) {
    nm->step = 0;
    for (nm->i = 0; nm->i < nm->numPoints; nm->i++) {
      if (nm->i != nm->l) {
        for (nm->j = 0; nm->j < nm->dim; nm->j++) {
          drand48_r(&nm->buffer, &nm->result);  // random number in 'result'
          nm->point[nm->i][nm->j] =
              (nm->result * 2.0 - 1.0);  // numbers between -1 and 1.
        }
      }
    }
  }
  // Caso 3: Inicializa com pontos aleatórios
  else {
    for (nm->i = 0; nm->i < nm->numPoints; nm->i++) {
      for (nm->j = 0; nm->j < nm->dim; nm->j++) {
        nm->point[nm->i] = (double *)malloc(sizeof(double) * nm->dim);
        drand48_r(&nm->buffer, &nm->result);  // random number in 'result'
        nm->point[nm->i][nm->j] =
            (nm->result * 2.0 - 1.0);  // numbers between -1 and 1.
      }
    }
  }
  //--//
  nm->k = 0;
}

/**
 * Inicialização de variáveis
 * nm : in - Valores Globais do NM
 * _dim : in - Número de dimensões
 * _error : in - Critério de parada, valor referece a casa decimal em que os
 pontos podem ser ditos iguais
 * _point : in - pontos inicial, se 'NULL' será gerado valores aleatórios
 */
void initial_variables(NelderMead *nm, int _dim, double _error,
                       double _point[]) {
  nm->dim = _dim;
  nm->numPoints = (_dim > 2) ? (_dim + 1) : 3;

  nm->point = (double **)malloc(
      sizeof(double) *
      nm->numPoints);  // aloca espaço para os ponteiros de cada ponto
  nm->cost = (double *)malloc(sizeof(double) * nm->numPoints);
  nm->centroid = (double *)malloc(sizeof(double) * nm->dim);  // Centroid
  nm->best_point = (double *)malloc(sizeof(double) * nm->dim);

  nm->h = nm->numPoints - 1;  // index of the worst solution
  nm->s = nm->numPoints - 2;  // index of the second worst solution
  nm->l = 0;                  // index of the best solution

  nm->point_reflection = (double *)malloc(
      sizeof(double) * nm->dim);  // nm->point generated by reflection
  nm->point_expansion = (double *)malloc(
      sizeof(double) * nm->dim);  // nm->point generated by expansion
  nm->point_contraction = (double *)malloc(
      sizeof(double) * nm->dim);  // nm->point generated by contraction

  nm->cost_reflection = 0.0;   // Cost of reflected nm->point
  nm->cost_expansion = 0.0;    // Cost of expanded nm->point
  nm->cost_contraction = 0.0;  // Cost of contracted nm->point

  nm->alpha = A_LFA;   // Used in reflection
  nm->gammma = G_AMA;  // Used in expansion
  nm->rho = R_HO;      // Used in contraction
  nm->sigma = S_GMA;   // Used in reduction

  nm->result = 0.0;
  nm->k = nm->i = nm->j = 0;
  nm->step = 0;

  nm->volume_ = MAX_VOLUME;
  nm->counter = 0;
  nm->reset = 1;  // Número de resetes
  nm->error = _error;

  srand48_r(time(NULL), &nm->buffer);  // random seed
  nm->initial_point = _point;

  set_points(nm);
}

/**
 * Ordena os pontos
 * nm : in - Valores Globais do NM
 */
void order(NelderMead *nm) {
  // Put in order solutions, ie, nm->point[0][x] is the best, ...,
  // nm->point[n+1][x] is the worst Bubble sort
  for (nm->i = 0; nm->i < nm->numPoints - 1;
       nm->i++)  // from first nm->point to the second last nm->point
  {
    for (nm->j = nm->i + 1; nm->j < nm->numPoints;
         nm->j++)  // From nm->i-nm->point to the last nm->point
    {
      if (nm->cost[nm->i] > nm->cost[nm->j]) {
        // change points using 'pointer'
        nm->point_temp = nm->point[nm->i];
        nm->point[nm->i] = nm->point[nm->j];
        nm->point[nm->j] = nm->point_temp;

        // change costs
        nm->result = nm->cost[nm->i];
        nm->cost[nm->i] = nm->cost[nm->j];
        nm->cost[nm->j] = nm->result;
      }
    }
  }
}

/**
 * Calcula o centroide dos pontos exceto o melhor ponto
 * nm : in - Valores Globais do NM
 * nm->centroid : out - Centoide para cada dimensão j
 */
void calculate_centroid(NelderMead *nm) {
  // Calculate nm->centroid
  for (nm->j = 0; nm->j < nm->dim; nm->j++) {
    nm->result = 0.0;
    nm->centroid[nm->j] = 0.0;  // Centroide = {0}
    for (nm->i = 0; nm->i < nm->numPoints; nm->i++) {
      if (nm->i != nm->h)  // The worst solution is not necessary to calculate
                           // the nm->centroid
      {
        nm->centroid[nm->j] += nm->point[nm->i][nm->j];
        nm->result += 1.0;
      }
    }
    nm->centroid[nm->j] /= (nm->result);
  }
}

void reset(NelderMead *nm) {
  // srand48_r(time(NULL),&nm->buffer); 		//random seed

  nm->cost_reflection = 0.0;   // Cost of reflected nm->point
  nm->cost_expansion = 0.0;    // Cost of expanded nm->point
  nm->cost_contraction = 0.0;  // Cost of contracted nm->point

  nm->result = 0.0;
  nm->k = nm->i = nm->j = 0;
  nm->step = -1;

  nm->volume_ = MAX_VOLUME;
  nm->counter = 0;

  set_points(nm);
}

/**
 * Calcula Volume dos pontos
 * nm : in - Valores Globais do NM
 * nm->volume : out - volume dos pontos
 */
void volume(NelderMead *nm) {
  double valor = 0.0;
  double total = 0.0;

  for (nm->i = 0; nm->i < nm->numPoints; nm->i++) {
    valor = 0.0;
    for (nm->j = 0; nm->j < nm->dim; nm->j++) {
      valor += pow(nm->point[nm->i][nm->j] - nm->centroid[nm->j], 2.0);
    }
    valor = sqrt(valor);      // Com este cálculo, 'valor' é a norma.
    valor = pow(valor, 2.0);  // valor é igual a normal²
    total += valor;
  }
  nm->volume_ = sqrt(total / nm->numPoints);
}

/**
 * Função Coupled Simulated Annealing
 * nm : in - Valores Globais do NM
 * costs : in - Vetor de custos
 * return : out - Vetor de pontos
 */
double *NM(NelderMead *nm, double _cost) {
  // if(nm->counter >= 100 || nm->volume_ <= nm->error) return NULL;

  // printf("Step %i N %i\n", nm->step, nm->counter);
  // printf("%1.2e\t%1.2e\t%1.2e\t%1.2e\t\n",nm->point[0][0],nm->point[1][0],nm->point[2][0],nm->volume_);

  do {
    switch (nm->step) {
      case 0:
        //--------------------- Inicializar Pontos -------------------//
        if (nm->k > 0) nm->cost[nm->k - 1] = _cost;
        if (nm->k != nm->numPoints) {
          nm->k++;
          return nm->point[nm->k - 1];
        }

      case 1:

        //------------------------- Inicializar Variáveis
        //----------------------//
        order(nm);
        calculate_centroid(nm);
        nm->volume_ = 1.0;
        nm->best_point = nm->point[nm->l];
        nm->counter = 0;

      case 2:
        //--------------------------- Reflection - Use nm->alpha
        //------------------//
        for (nm->j = 0; nm->j < nm->dim; nm->j++) {
          nm->point_reflection[nm->j] = fmod(
              nm->centroid[nm->j] +
                  nm->alpha * (nm->centroid[nm->j] - nm->point[nm->h][nm->j]),
              1);
        }
        nm->step = 3;
        return nm->point_reflection;
        //---------------------------------------------------------------------//
      case 3:

        nm->cost_reflection = _cost;
        if (nm->cost[nm->l] <= nm->cost_reflection &&
            nm->cost_reflection < nm->cost[nm->s]) {
          swap_worst(nm->point_reflection);
          // nm->point_temp = nm->point[nm->h];
          // nm->point[nm->h] = nm->point_reflection;
          // nm->point_reflection = nm->point_temp;
          nm->cost[nm->h] = nm->cost_reflection;

          order(nm);
          break;
        } else if (nm->cost_reflection < nm->cost[nm->l]) {
          //--------------------------- Expansion - Use nm->gammma
          //------------------//
          for (nm->j = 0; nm->j < nm->dim; nm->j++) {
            nm->point_expansion[nm->j] =
                fmod(nm->centroid[nm->j] +
                         nm->gammma * (nm->point_reflection[nm->j] -
                                       nm->centroid[nm->j]),
                     1);
          }
          nm->step = 4;
          return nm->point_expansion;
          //--------------------------------------------------------------------//
        } else if (nm->cost[nm->s] <= nm->cost_reflection &&
                   nm->cost_reflection < nm->cost[nm->h]) {
          //------------------- Outside Contraction - Use nm->rho
          //------------------//
          for (nm->j = 0; nm->j < nm->dim; nm->j++) {
            nm->point_contraction[nm->j] = fmod(
                nm->centroid[nm->j] + nm->rho * (nm->point_reflection[nm->j] -
                                                 nm->centroid[nm->j]),
                1);
          }
          nm->step = 5;
          return nm->point_contraction;
          //--------------------------------------------------------------------//
        } else if (nm->cost_reflection >= nm->cost[nm->h]) {
          //-------------------- Inside Contraction - Use nm->rho
          //------------------//
          for (nm->j = 0; nm->j < nm->dim; nm->j++) {
            // nm->point_contraction[nm->j] = fmod(nm->centroid[nm->j] - nm->rho
            // * (nm->point_reflection[nm->j] - nm->centroid[nm->j]), 1);
            nm->point_contraction[nm->j] =
                fmod(nm->centroid[nm->j] - nm->rho * (nm->centroid[nm->j]) -
                         nm->point[nm->h][nm->j],
                     1);
          }
          nm->step = 6;
          return nm->point_contraction;
          //-------------------------------------------------------------------//
        }

      case 4:

        nm->cost_expansion = _cost;
        if (nm->cost_expansion < nm->cost_reflection) {
          swap_worst(nm->point_expansion);
          // nm->point_temp = nm->point[nm->h];
          // nm->point[nm->h] = nm->point_expansion;
          // nm->point_expansion = nm->point_temp;
          nm->cost[nm->h] = nm->cost_expansion;
        } else {
          swap_worst(nm->point_reflection);
          // nm->point_temp = nm->point[nm->h];
          // nm->point[nm->h] = nm->point_reflection;
          // nm->point_reflection = nm->point_temp;
          nm->cost[nm->h] = nm->cost_reflection;
        }
        order(nm);
        break;

      case 5:

        nm->cost_contraction = _cost;
        if (nm->cost_contraction <= nm->cost_reflection) {
          swap_worst(nm->point_contraction);
          // nm->point_temp = nm->point[nm->h];
          // nm->point[nm->h] = nm->point_contraction;
          // nm->point_contraction = nm->point_temp;
          nm->cost[nm->h] = nm->cost_contraction;

          order(nm);
          break;
        } else {
          nm->k = 0;
          nm->step = 7;
          break;
        }

      case 6:

        nm->cost_contraction = _cost;
        if (nm->cost_contraction < nm->cost[nm->h]) {
          swap_worst(nm->point_contraction);
          // nm->point_temp = nm->point[nm->h];
          // nm->point[nm->h] = nm->point_contraction;
          // nm->point_contraction = nm->point_temp;
          nm->cost[nm->h] = nm->cost_contraction;

          order(nm);
          nm->step = 8;
          break;
        } else {
          nm->k = 0;
          nm->step = 7;
          break;
        }
    }
    //------------------------ Reduction/Shrink - Use nm->sigma
    //------------------//
    if (nm->step == 7) {
      if (nm->k > 0) nm->cost[nm->k - 1] = _cost;
      for (; nm->k < nm->numPoints;) {
        if (nm->k !=
            nm->l)  // For all but the best_point, replace the nm->point
        {
          for (nm->j = 0; nm->j < nm->dim; nm->j++) {
            nm->point[nm->k][nm->j] = fmod(
                nm->point[nm->l][nm->j] + nm->sigma * (nm->point[nm->k][nm->j] -
                                                       nm->point[nm->l][nm->j]),
                1);
          }
          nm->k++;
          return nm->point[nm->k - 1];
        } else
          nm->k++;
      }
      order(nm);
      // n_shrinks++;
    }
    //-----------------------------------------------------------------------//

    calculate_centroid(nm);
    volume(nm);

    nm->step = 2;
    nm->counter++;

    // printf("%1.2e > %1.2e\n", nm->volume_, nm->error);
  } while (nm->volume_ > nm->error);

  return NULL;
}

/**
 * Libera a memória
 * nm : in - Valores Globais do NM
 */
void finalizeNM(NelderMead *nm) {
  if (nm->point) {
    for (nm->j = 0; nm->j < nm->numPoints; nm->j++)
      if (nm->point[nm->j]) free(nm->point[nm->j]);
  }
  if (nm->point) free(nm->point);
  if (nm->cost) free(nm->cost);
  if (nm->centroid) free(nm->centroid);
  if (nm->point_reflection) free(nm->point_reflection);
  if (nm->point_expansion) free(nm->point_expansion);
  if (nm->point_contraction) free(nm->point_contraction);
  if (nm->initial_point) free(nm->initial_point);
}